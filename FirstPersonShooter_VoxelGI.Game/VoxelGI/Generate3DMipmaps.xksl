namespace Xenko.Rendering.Shadows
{
    shader Generate3DMipmaps : Math, Texturing, ComputeShaderBase
    {
		stage Texture3D<half4> VoxelsTexR;
		stage RWTexture3D<half4> VoxelsTexW;
        override void Compute()
        {
            uint3 pos = streams.DispatchThreadId;

            uint width = 0;
            uint height = 0;
            uint depth = 0;
            VoxelsTexW.GetDimensions(width,height,depth);

            uint rwidth = 0;
            uint rheight = 0;
            uint rdepth = 0;
            VoxelsTexR.GetDimensions(rwidth,rheight,rdepth);

            //If not a border pixel, average, otherwise fill empty
            if (pos.x!=0&&pos.y!=0&&pos.z!=0&&pos.x!=width-1&&pos.y!=height-1&&pos.z!=depth-1)
            {
                uint3 posR = pos*2+uint3(0,0,rdepth-depth*2);
                VoxelsTexW[pos] = (
                    VoxelsTexR.Load(int4(posR,0))+
                    VoxelsTexR.Load(int4(posR+uint3(1,0,0),0))+
                    VoxelsTexR.Load(int4(posR+uint3(1,1,0),0))+
                    VoxelsTexR.Load(int4(posR+uint3(1,0,1),0))+
                    VoxelsTexR.Load(int4(posR+uint3(0,1,1),0))+
                    VoxelsTexR.Load(int4(posR+uint3(0,1,0),0))+
                    VoxelsTexR.Load(int4(posR+uint3(0,0,1),0))+
                    VoxelsTexR.Load(int4(posR+uint3(1,1,1),0))
                )/8.0;
                //I imagine I could just sample in the middle of the texels with linear filtering, 
                //but for now this is fast enough and easier to make sure it's right
            }
            else
            {
                VoxelsTexW[pos] = float4(0,0,0,0);
            }
        }
    };
}
