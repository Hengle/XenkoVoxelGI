namespace Xenko.Rendering.Shadows
{
    shader ArrangeFragments : ComputeShaderBase
    {
        struct VoxelFragment{
            float4 color;
            float z;
            float ndotup;
        };
        stage RWBuffer<uint> VoxelFragmentsCounts;
        stage RWStructuredBuffer<VoxelFragment> VoxelFragments;


        stage RWTexture3D<half4> VoxelVolumeW0;

        [Link("Nowhere")]
        static float4 columnSum[64];

        [Link("Nowhere2Go")]
        static float columnCount[64];

        [Link("Nowhere2GoButHere")]
        static float4 columnSendReceive[64];//{IsSender?, IsReceiver?, Min Send Depth, Max Receive Depth}

        void SolidificationStep(uint2 pos, int clipZOffset, int j, inout float lastSendZ)
        {
            if (columnSendReceive[j].x == 0.0 || columnSendReceive[j].z >= columnSendReceive[j].w)
            {
                if (columnSendReceive[j].y == 1.0)
                {
                    if (lastSendZ < j)
                    {
                        for (int ii = lastSendZ; ii < j ;ii ++)
                        {
                            VoxelVolumeW0[int3(pos.x,pos.y, ii+clipZOffset)] = float4(0,0,0,1);
                        }
                    }
                    lastSendZ = 1000;
                }
                if (columnSendReceive[j].x == 1.0)
                {
                    lastSendZ = j+1;
                }
            }
        }

        override void Compute()
        {
            uint2 pos = streams.DispatchThreadId.xy;

            int clip = streams.DispatchThreadId.z;
            int clipZOffset = 64*clip;

            uint countIndex = pos.x + pos.y * 128 + clip * (128 * 128);
            uint count = min(VoxelFragmentsCounts[countIndex],63);

            uint VoxelFragmentsIndex = pos.x * 64 + pos.y * 128 * 64 + clip * (128 * 128 * 64);

            count += VoxelFragmentsIndex;
            for ( uint i = VoxelFragmentsIndex; i < count; i ++)
            {
                VoxelFragment frag = VoxelFragments[i];
                int z = (int)floor(frag.z);
                columnSum[z] += frag.color;
                columnCount[z] += 1.0;
                if (frag.ndotup < 0 && (columnSendReceive[z].x != 1.0 || frag.z < columnSendReceive[z].z))
                {
                    columnSendReceive[z].xz = float2(1.0,frag.z);
                }
                else if (frag.ndotup > 0)
                {
                    columnSendReceive[z].yw = float2(1.0, max(columnSendReceive[z].w,frag.z));
                }
                VoxelVolumeW0[int3(pos.x,pos.y, z+clipZOffset)] = columnSum[z]/columnCount[z];
            }
            //Can't claim that this makes sense to me, but moving the inner loop to a function
            //gains a few ms. Originally I wanted to unroll but I get a "Flattened side effects"
            //error if I tell it to. Manually unrolling works, but obviously that's dreadful.
            //So I figured I could at least manually unroll by calling a function, but I get the same
            //error. However sticking the function in a loop...gives me the same speed up. ??
            int lastSendZ = 1000;
            for (int j = 0; j < 64 ; j++)
            {
                SolidificationStep(pos, clipZOffset, j, lastSendZ);
            }
        }
    };
}
