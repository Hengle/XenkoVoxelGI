namespace Xenko.Rendering.Voxels
{
    shader VoxelMipmapSimple : Math, Texturing, ComputeShaderBase
    {
        stage float3 ReadOffset;
		stage Texture3D<half4> ReadTex;
		stage RWTexture3D<half4> WriteTex;
        override void Compute()
        {
            uint3 pos = streams.DispatchThreadId;

            uint width = 0;
            uint height = 0;
            uint depth = 0;
            WriteTex.GetDimensions(width,height,depth);

            uint rwidth = 0;
            uint rheight = 0;
            uint rdepth = 0;
            ReadTex.GetDimensions(rwidth,rheight,rdepth);

            uint3 posR = pos*2+(uint3)ReadOffset;
            float4 fragmentSum = (
                ReadTex.Load(int4(posR, 0)) +
                ReadTex.Load(int4(posR + uint3(1, 0, 0), 0)) +
                ReadTex.Load(int4(posR + uint3(1, 1, 0), 0)) +
                ReadTex.Load(int4(posR + uint3(1, 0, 1), 0)) +
                ReadTex.Load(int4(posR + uint3(0, 1, 1), 0)) +
                ReadTex.Load(int4(posR + uint3(0, 1, 0), 0)) +
                ReadTex.Load(int4(posR + uint3(0, 0, 1), 0)) +
                ReadTex.Load(int4(posR + uint3(1, 1, 1), 0))
            );
            fragmentSum.a /= 2;
            WriteTex[pos] = (fragmentSum / 4.0);
            //Rather than divide by 8...
            //I figure that since the visible surface of the
            //emitter is a 2D projection, it should decrease
            //by 2 dimensions rather than 3 (i.e divide by 4 rather than 8).

            //This makes the lighting fall-off much more realistic,
            //but I find the opacity coverage too strong then.
            //so keep that dividing by 8.
        }
    };
}
