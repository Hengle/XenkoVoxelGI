// Copyright (c) Xenko contributors (https://xenko.com) and Silicon Studio Corp. (https://www.siliconstudio.co.jp)
// Distributed under the MIT license. See the LICENSE.md file in the project root for more information.
namespace Xenko.Rendering.Shadows
{
    /// <summary>
    /// Voxelization, projects to axis of largest area and writes fragments to buffer
    /// </summary>
    shader IsotropicVoxelFragment : Math, Transformation, ShaderBase, Texturing, NormalStream, PositionStream4, MaterialPixelStream, MaterialPixelShadingStream
    {
        struct VoxelFragment{
            float4 color;
            float z;
            float ndotup;
        };
        cbuffer PerView.VoxelizerStorer
        {
            float4x4 VoxelMatrix;
            float4x4 VoxelMatrixViewport;
            int clipMapCount;
            float3 clipMapResolution;
        }
        rgroup PerView.VoxelizerStorer
	    {
		    stage RWTexture3D<half4> VoxelVolumeW0;
            stage RWStructuredBuffer<VoxelFragment> VoxelFragments;
            stage RWBuffer<uint> VoxelFragmentsCounter;
	    }

        stage stream uint clipPos;
        stage stream float clipScale;

        override stage void PSMain()
        {
            int3 clipMapResolutionI = (int3)clipMapResolution;
            float3 texPos = mul(float4(streams.PositionWS.xyz,1.0),VoxelMatrix).xyz;
            texPos = (texPos-0.5)  * streams.clipScale + 0.5;

            //Currently Z clipping doesn't seem to work right, this'll do for now
            if (dot(texPos,float3(1,1,1)) != dot(saturate(texPos),float3(1,1,1))) discard;

            streams.IsFrontFace = true;
                base.PSMain();

            int3 pixelPos = int3(floor(saturate(texPos) * clipMapResolution));
            uint VoxelFragmentsIndex = (pixelPos.x+pixelPos.y*clipMapResolutionI.x) + streams.clipPos;

            uint index = 0;
            InterlockedAdd(VoxelFragmentsCounter[VoxelFragmentsIndex], 1, index);

            VoxelFragment frag;
                frag.color = float4(streams.ColorTarget.rgb,1.0);
                frag.z = saturate(texPos.z)*clipMapResolutionI.z;
                frag.ndotup = dot(streams.normalWS,float3(0,1,0));

            VoxelFragments[VoxelFragmentsIndex*clipMapResolutionI.z + min(clipMapResolutionI.z-1,index)] = frag;
        }
        float triarea(float2 p1, float2 p2, float2 p3)
        {
            return abs(((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y))/2.0);
        }
        //max clipmap count of 3...perhaps there's a way to use the templating?
        [maxvertexcount(9)]
        void GSMain(triangle Input input[3], inout TriangleStream<Output> triangleStream)
        {
            int3 clipMapResolutionI = (int3)clipMapResolution;
            for ( int i = 0; i < 3 ; i++)
            {
                input[i].ShadingPosition.xyz = mul(float4(input[i].PositionWS.xyz,1.0),VoxelMatrixViewport).xyz;
            }

            float areaX = triarea(input[0].ShadingPosition.yz,input[1].ShadingPosition.yz,input[2].ShadingPosition.yz);
            float areaY = triarea(input[0].ShadingPosition.xz,input[1].ShadingPosition.xz,input[2].ShadingPosition.xz);
            float areaZ = triarea(input[0].ShadingPosition.xy,input[1].ShadingPosition.xy,input[2].ShadingPosition.xy);

            for ( int map = 0 ; map < clipMapCount; map++)
            {
                uint clippos = map * (clipMapResolutionI.x * clipMapResolutionI.y);
                float clipscale = pow(2,-map);
                for ( int i = 0; i < 3 ; i++)
                {
                    streams = input[i];

                    streams.clipPos = clippos;
                    streams.clipScale = clipscale;

                    if (areaX > areaY && areaX > areaZ)
                        streams.ShadingPosition.xyz = streams.ShadingPosition.yzx;
                    else if (areaY > areaZ && areaY > areaX)
                        streams.ShadingPosition.xyz = streams.ShadingPosition.xzy;

                    streams.ShadingPosition.xyz *= streams.clipScale;
                    streams.ShadingPosition.w = 1.0;
                    triangleStream.Append(streams);
                }
                triangleStream.RestartStrip();
            }

        }
    };
}
